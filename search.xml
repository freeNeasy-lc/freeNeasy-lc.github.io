<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Spring中Model、ModelMap及ModelAndView详解]]></title>
    <url>%2F2019%2F05%2F21%2FModel%2F</url>
    <content type="text"><![CDATA[若方法上声明了@ResponseBody，则会直接将返回值输出到页面。 Model(org.springframework.ui.Model)Model是用来传输数据的，如果用来接收一组数据List，Model实际上就是ModelMap。 public class ExtendedModelMap extends ModelMap implements Model spring.velocity.suffix=.html弄了半天，后缀名改了没发现，难受例子： 12345@RequestMapping(value = "/test")public String modelTest(Model model, String name) &#123; model.addAttribute("name", name); return "hello";&#125; 创建hello.html 12345678&lt;html&gt;&lt;body&gt;&lt;pre&gt; Hello Vmvalue: $&#123;name&#125;&lt;/pre&gt;&lt;/body&gt;&lt;/html&gt; ModelMap(org.springframework.ui.ModelMap)Spring框架自动创建ModelMap的实例，并作为Controller方法的参数传入，用户无需自己创建对象。ModelMap主要用于把controller方法处理的数据传递到jsp界面，把需要传输的数据放到ModelMap对象中即可。通过addAttribute()方法传递参数。ModelMap本身不能设置页面的跳转，可以通过Controller方法的返回值来指定跳转的页面。跟Model用法差不多。返回值设置跳转的页面12345@RequestMapping(value = "/test")public String modelTest(ModelMap model, String name) &#123; model.addAttribute("name", name); return "hello";&#125; ModelAndView(org.springframework.web.servlet.ModelAndView)作用： 设置跳转的视图地址，这是ModelAndView和ModelMap的主要区别。ModelAndView view = new ModelAndView(“path:ok”);或者通过setViewName设置视图地址 把controller方法中处理的数据传到jsp页面，在controller方法中把jsp界面需要的数据放到ModelAndView对象中即可。然后return mv。通过addObject()传递参数。 123456789@RequestMapping("model")public ModelAndView modelTest(String name) &#123; //构建ModelAndView实例，并设置跳转的视图路径 /*ModelAndView mv = new ModelAndView(); mv.setViewName("hello");*/ ModelAndView mv = new ModelAndView("hello"); mv.addObject("name",name); return mv;&#125; controller方法的返回值如果是ModelAndView，则其即包含模型数据信息，又包含视图信息，这样SpringMVC将使用包含的视图对模型数据进行渲染，可以简单地将模型数据看成一个Map&lt;String, Object&gt;对象。]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Model</tag>
        <tag>ModelMap</tag>
        <tag>ModelAndView</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[牛客网中级项目（二）]]></title>
    <url>%2F2019%2F05%2F21%2FNewCoder2%2F</url>
    <content type="text"><![CDATA[MyBatis集成在application.properties增加spring配置数据库链接地址 12345678spring.datasource.url=jdbc:mysql://localhost:3306/toutiao?useUnicode=true&amp;amp;characterEncoding=utf8&amp;amp;useSSL=falsespring.datasource.username=rootspring.datasource.password=123mybatis.config-location=classpath:mybatis-config.xml#logging.level.root=DEBUGspring.velocity.suffix=.htmlspring.velocity.cache=false#spring.velocity.toolbox-config-location=toolbox.xml pom.xml引入mybatis-spring-boot-starter和mysql-connector-java 1234567891011&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.1.1&lt;/version&gt;&lt;/dependency&gt; mybatis-config.xml 12345678910111213141516171819&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN" "http://mybatis.org/dtd/mybatis-3-config.dtd"&gt;&lt;configuration&gt; &lt;settings&gt; &lt;!-- Globally enables or disables any caches configured in any mapper under this configuration --&gt; &lt;setting name="cacheEnabled" value="true"/&gt; &lt;!-- Sets the number of seconds the driver will wait for a response from the database --&gt; &lt;setting name="defaultStatementTimeout" value="3000"/&gt; &lt;!-- Enables automatic mapping from classic database column names A_COLUMN to camel case classic Java property names aColumn --&gt; &lt;setting name="mapUnderscoreToCamelCase" value="true"/&gt; &lt;!-- Allows JDBC support for generated keys. A compatible driver is required. This setting forces generated keys to be used if set to true, as some drivers deny compatibility but still work --&gt; &lt;setting name="useGeneratedKeys" value="true"/&gt; &lt;/settings&gt; &lt;!-- Continue going here --&gt;&lt;/configuration&gt; 注解配置@Mapper注解参考：https://blog.csdn.net/weixin_39666581/article/details/81057385 作用： 1:为了把mapper这个DAO交給Spring管理 2:为了不再写mapper映射文件 3:为了给mapper接口自动根据一个添加@Mapper注解的接口生成一个实现类 在方法参数的前面写上@Param(“参数名”),表示给参数命名,名称就是括号中的内容 List selectByUserIdAndOffset(@Param(“userId”) int userId, @Param(“offset”) int offset, @Param(“limit”) int limit); 给入参的int userId,int offset,int limit分别命名为userId,offset,limit, 然后就可以传递参数了，XML映射文件中的sql语句就可以得到相应的参数啦。 ​ ​ WHERE user_id = #{userId}​ ​ ORDER BY id DESC​ LIMIT #{offset},#{limit} @Param是MyBatis所提供的(org.apache.ibatis.annotations.Param)，作为Dao层的注解，作用是用于传递参数，从而可以与SQL中的的字段名相对应。 123456789101112131415161718192021222324252627package com.nowcoder.dao;import com.nowcoder.model.News;import com.nowcoder.model.User;import org.apache.ibatis.annotations.*;import java.util.List;@Mapperpublic interface NewsDAO &#123; String TABLE_NAME = "news"; String INSERT_FIELDS = " title, link, image, like_count, comment_count, created_date, user_id"; String SELECT_FIELDS = "id" + INSERT_FIELDS; @Insert(&#123;"insert into ", TABLE_NAME, "(", INSERT_FIELDS, ") values (#&#123;title&#125;,#&#123;link&#125;,#&#123;image&#125;,#&#123;likeCount&#125;,#&#123;commentCount&#125;,#&#123;createdDate&#125;,#&#123;userId&#125;)"&#125;) int addNews(News news); List&lt;News&gt; selectByUserIdAndOffset(@Param("userId") int userId, @Param("offset") int offset, @Param("limit") int limit); @Select(&#123;"select", SELECT_FIELDS, "from", TABLE_NAME, "where id=#&#123;id&#125;"&#125;) News selectById(int id); @Update(&#123;"update", TABLE_NAME, "set password=#&#123;password&#125; where id=#&#123;id&#125;"&#125;) void updatePassword(User user); @Delete(&#123;"delete from", TABLE_NAME,"where id=#&#123;id&#125;"&#125;) void deleteById(int id);&#125; XML配置在相同的包目录下定义同名的XML NewsDAO.xml MyBatis 的真正强大在于它的映射语句，这是它的魔力所在。由于它的异常强大，映射器的 XML 文件就显得相对简单。如果拿它跟具有相同功能的 JDBC 代码进行对比，你会立即发现省掉了将近 95% 的代码。MyBatis 为聚焦于 SQL 而构建，以尽可能地为你减少麻烦。官方的话有味道啊。 使用xml的好处，可以在里面写一些复杂的操作，减少代码量。 1234567891011121314151617181920&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd" &gt;&lt;mapper namespace="com.nowcoder.dao.NewsDAO"&gt; &lt;sql id="table"&gt;news&lt;/sql&gt; &lt;sql id="selectFields"&gt;id,title, link, image, like_count, comment_count,created_date,user_id &lt;/sql&gt; &lt;select id="selectByUserIdAndOffset" resultType="com.nowcoder.model.News"&gt; SELECT &lt;include refid="selectFields"/&gt; FROM &lt;include refid="table"/&gt; &lt;if test="userId != 0"&gt; WHERE user_id = #&#123;userId&#125; &lt;/if&gt; ORDER BY id DESC LIMIT #&#123;offset&#125;,#&#123;limit&#125; &lt;/select&gt;&lt;/mapper&gt; ViewObject自定义类ViewObject，ViewObject是个map的包装类，方便把任何类型的数据放到一起。通过model将数据输送到页面。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152package com.nowcoder.model;import java.util.HashMap;import java.util.Map;public class ViewObject &#123; private Map&lt;String, Object&gt; objs = new HashMap&lt;String, Object&gt;(); public void set(String key, Object value) &#123; objs.put(key, value); &#125; public Object get(String key) &#123; return objs.get(key); &#125;&#125;package com.nowcoder.controller;import com.nowcoder.model.News;import com.nowcoder.model.ViewObject;import com.nowcoder.service.NewsService;import com.nowcoder.service.UserService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.ui.Model;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestMethod;import java.util.ArrayList;import java.util.List;@Controllerpublic class HomeController &#123; @Autowired NewsService newsService; @Autowired UserService userService; @RequestMapping(path = &#123;"/", "/index"&#125;, method = &#123;RequestMethod.GET, RequestMethod.POST&#125;) public String index(Model model) &#123; List&lt;News&gt; newsList = newsService.getLatestNews(0,0,10); List&lt;ViewObject&gt; vos = new ArrayList&lt;&gt;(); for (News news : newsList) &#123; ViewObject vo = new ViewObject(); vo.set("news", news); vo.set("user", userService.getUser(news.getUserId())); vos.add(vo); &#125; model.addAttribute("vos", vos); return "home"; &#125;&#125; DateToolvelocity自带工具类导入 toolbox.xml 1234567&lt;toolbox&gt;&lt;tool&gt; &lt;key&gt;date&lt;/key&gt; &lt;scope&gt;application&lt;/scope&gt; &lt;class&gt;org.apache.velocity.tools.generic.DateTool&lt;/class&gt;&lt;/tool&gt;&lt;/toolbox&gt; application.properties 12345678spring.datasource.url=jdbc:mysql://localhost:3306/toutiao?useUnicode=true&amp;amp;characterEncoding=utf8&amp;amp;useSSL=falsespring.datasource.username=rootspring.datasource.password=123mybatis.config-location=classpath:mybatis-config.xml#logging.level.root=DEBUGspring.velocity.suffix=.htmlspring.velocity.cache=falsespring.velocity.toolbox-config-location=toolbox.xml]]></content>
      <categories>
        <category>项目</category>
      </categories>
      <tags>
        <tag>MyBatis</tag>
        <tag>Mapper注解</tag>
        <tag>XML配置</tag>
        <tag>ViewObject</tag>
        <tag>DateTool</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MVC模式&DAO，Service，Controller、View层级理解]]></title>
    <url>%2F2019%2F05%2F21%2FMVC%2F</url>
    <content type="text"><![CDATA[MVC模式你在浏览器输入好用户名和密码之后，点击登录，浏览器会给服务器发个请求。 服务器接到请求之后，按照预先设定的路由规则把参数传给相应的controller。 controller判断参数合法性之后，从model那边拿数据。 model通过orm从数据库里面把数据取出来、封装成对象给controller。 之后，controller根据结果进行判断，然后加载相应的view（模板）。 最后controller把模板渲染出来的html打印到网络流中。 作者：飞龙链接：https://www.zhihu.com/question/31397745/answer/52790560来源：知乎 总统在舞台上演讲，总统口渴了需要水；秘书负责传唤幕后人员送上水来；后台人员负责送水。总统以及舞台是view，秘书是controller，后台人员是model。总统的要求都是由model实际来完成的，controller只是个传话的。世界中很多实际场景都是按这个步骤来运行的，只是我们没有发觉。作者：bobo链接：https://www.zhihu.com/question/31397745/answer/88755021来源：知乎 DAO层，Service层，Controller层、View层DAO层：DAO层主要是做数据持久层的工作，负责与数据库进行联络的一些任务都封装在此，DAO层的设计首先是设计DAO的接口，然后在Spring的配置文件中定义此接口的实现类，然后就可在模块中调用此接口来进行数据业务的处理，而不用关心此接口的具体实现类是哪个类，显得结构非常清晰，DAO层的数据源配置，以及有关数据库连接的参数都在Spring的配置文件中进行配置。 Service层：Service层主要负责业务模块的逻辑应用设计。同样是首先设计接口，再设计其实现的类，接着再Spring的配置文件中配置其实现的关联。这样我们就可以在应用中调用Service接口来进行业务处理。Service层的业务实现，具体要调用到已定义的DAO层的接口，封装Service层的业务逻辑有利于通用的业务逻辑的独立性和重复利用性，程序显得非常简洁。 Controller层：Controller层负责具体的业务模块流程的控制，在此层里面要调用Serice层的接口来控制业务流程，控制的配置也同样是在Spring的配置文件里面进行，针对具体的业务流程，会有不同的控制器，我们具体的设计过程中可以将流程进行抽象归纳，设计出可以重复利用的子单元流程模块，这样不仅使程序结构变得清晰，也大大减少了代码量。 View层：此层与控制层结合比较紧密，需要二者结合起来协同工发。View层主要负责前台jsp页面的表示， DAO层，Service层这两个层次都可以单独开发，互相的耦合度很低，完全可以独立进行，这样的一种模式在开发大项目的过程中尤其有优势，Controller，View层因为耦合度比较高，因而要结合在一起开发，但是也可以看作一个整体独立于前两个层进行开发。这样，在层与层之前我们只需要知道接口的定义，调用接口即可完成所需要的逻辑单元应用，一切显得非常清晰简单。 DAO设计的总体规划需要和设计的表，和实现类之间一一对应。 DAO层所定义的接口里的方法都大同小异，这是由我们在DAO层对数据库访问的操作来决定的，对数据库的操作，我们基本要用到的就是新增，更新，删除，查询等方法。因而DAO层里面基本上都应该要涵盖这些方法对应的操作。除此之外，可以定义一些自定义的特殊的对数据库访问的方法。 Service逻辑层设计 Service层是建立在DAO层之上的，建立了DAO层后才可以建立Service层，而Service层又是在Controller层之下的，因而Service层应该既调用DAO层的接口，又要提供接口给Controller层的类来进行调用，它刚好处于一个中间层的位置。每个模型都有一个Service接口，每个接口分别封装各自的业务处理方法。 在DAO层定义的一些方法，在Service层并没有使用，那为什么还要在DAO层进行定义呢？这是由我们定义的需求逻辑所决定的。DAO层的操作 经过抽象后基本上都是通用的，因而我们在定义DAO层的时候可以将相关的方法定义完毕，这样的好处是在对Service进行扩展的时候不需要再对DAO层进行修改，提高了程序的可扩展性。-——————–作者：zdwzzu2006来源：CSDN原文：https://blog.csdn.net/zdwzzu2006/article/details/6053006 SSM框架中Dao层，Mapper层，controller层，service层，model层，entity层SSM是sping+springMVC+mybatis集成的框架。 MVC即model view controller。 model层=entity层。存放我们的实体类，与数据库中的属性值基本保持一致。 service层。存放业务逻辑处理，也是一些关于数据库处理的操作，但不是直接和数据库打交道，他有接口还有接口的实现方法，在接口的实现方法中需要导入mapper层，mapper层是直接跟数据库打交道的，他也是个接口，只有方法名字，具体实现在mapper.xml文件里，service是供我们使用的方法。 mapper层=dao层，现在用mybatis逆向工程生成的mapper层，其实就是dao层。对数据库进行数据持久化操作，他的方法语句是直接针对数据库操作的，而service层是针对我们controller，也就是针对我们使用者。service的impl是把mapper和service进行整合的文件。 （多说一句，数据持久化操作就是指，把数据放到持久化的介质中，同时提供增删改查操作，比如数据通过hibernate插入到数据库中。） controller层。控制器，导入service层，因为service中的方法是我们使用到的，controller通过接收前端传过来的参数进行业务操作，在返回一个指定的路径或者数据表。 在实际开发中的Service层可能被处理为实体Service层，而不是接口，业务逻辑直接写在Service（Class，不是Interface）层中，Controller直接调用Service，Service调用Mapper。 当然了，Service之间也是可以互相调用！-——————–作者：安逸的程序猿来源：CSDN原文：https://blog.csdn.net/ma726518972/article/details/80262948 Springboot的entity,dao,controller,service层级理解Dao层：持久层，主要与数据库交互DAO层首先会创建Dao接口，接着就可以在配置文件中定义该接口的实现类；接着就可以在模块中调用Dao的接口进行数据业务的处理，而不用关注此接口的具体实现类是哪一个类，Dao层的数据源和数据库连接的参数都是在配置文件中进行配置的。 Entity层：实体层，数据库在项目中的类主要用于定义与数据库对象应的属性，提供get/set方法,tostring方法,有参无参构造函数。 Service层：业务层 控制业务业务模块的逻辑应用设计，和DAO层一样都是先设计接口，再创建要实现的类，然后在配置文件中进行配置其实现的关联。接下来就可以在service层调用接口进行业务逻辑应用的处理。 好处：封装Service层的业务逻辑有利于业务逻辑的独立性和重复利用性。 Controller层：控制层 控制业务逻辑具体的业务模块流程的控制，controller层主要调用Service层里面的接口控制具体的业务流程，控制的配置也要在配置文件中进行。 View层此层与控制层结合比较紧密，需要二者结合起来协同工发。View层主要负责前台jsp页面的表示。 Controller和Service的区别是：Controller负责具体的业务模块流程的控制；Service层负责业务模块的逻辑应用设计 总结：具体的一个项目中有：controller层调用了Service层的方法，Service层调用Dao层的方法，其中调用的参数是使用Entity层进行传递的。 参考：https://www.cnblogs.com/almm/p/10802419.html]]></content>
      <categories>
        <category>MVC</category>
      </categories>
      <tags>
        <tag>MVC</tag>
        <tag>Dao/Mapper层</tag>
        <tag>Model/Entity层</tag>
        <tag>Service层</tag>
        <tag>Controller层</tag>
        <tag>View层</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ResponseBody详解]]></title>
    <url>%2F2019%2F05%2F21%2FResponseBody%2F</url>
    <content type="text"><![CDATA[@responseBody注解的作用是将controller的方法返回的对象通过适当的转换器转换为指定的格式之后，写入到response对象的body区，通常用来返回JSON数据或者是XML数据，需要注意的呢，在使用此注解之后不会再走视图处理器，而是直接将数据写入到输入流中，他的效果等同于通过response对象输出指定格式的数据。 12345678910111213 @RequestMapping("/login") @ResponseBody public User login(User user)&#123; return user; &#125; //User字段：userName pwd //那么在前台接收到的数据为：'&#123;"userName":"xxx","pwd":"xxx"&#125;' //效果等同于如下代码： @RequestMapping("/login") public void login(User user, HttpServletResponse response)&#123; response.getWriter.write(JSONObject.fromObject(user).toString()); &#125; 以上参考：https://www.cnblogs.com/qiankun-site/p/5774325.html 如果在一个方法上使用了@RequestMapping注解，这时候，方法的返回值通常解析为跳转的路径， 也就是说，要跳转到指定的jsp页面。在这个代码实例中，要跳转到的是 Hello World.jsp 页面。 因为工程中尚未添加这个jsp文件，所以报出了 404 错误 （The requested resource is not available）。 12345678@Controllerpublic class TestController &#123; @RequestMapping(path = "/test") //@ResponseBody public String test() &#123; return "Hello World"; &#125;&#125; 如果添加了 @ResponseBody 这个注解， 则表明该方法的返回值直接写入到 HTTP Response Body 中。 12345678@Controllerpublic class TestController &#123; @RequestMapping(path = "/test") @ResponseBody public String test() &#123; return "Hello World"; &#125;&#125; 一般在异步获取数据时使用，在使用@RequestMapping后，返回值通常解析为跳转路径，加上@responsebody后返回结果不会被解析为跳转路径，而是直接写入HTTP response body中。比如异步获取json数据，加上@responsebody后，会直接返回json数据。]]></content>
      <categories>
        <category>SSM</category>
      </categories>
      <tags>
        <tag>ResponseBody</tag>
        <tag>RequestMapping</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IOC与DI]]></title>
    <url>%2F2019%2F05%2F20%2FIOC%26DI%2F</url>
    <content type="text"><![CDATA[原文地址：http://jinnianshilongnian.iteye.com/blog/1413846 IoC是什么 Ioc—Inversion of Control，即“控制反转”，不是什么技术，而是一种设计思想。在Java开发中，Ioc意味着将你设计好的对象交给容器控制，而不是传统的在你的对象内部直接控制。如何理解好Ioc呢？理解好Ioc的关键是要明确“谁控制谁，控制什么，为何是反转（有反转就应该有正转了），哪些方面反转了”，那我们来深入分析一下： ●谁控制谁，控制什么：传统Java SE程序设计，我们直接在对象内部通过new进行创建对象，是程序主动去创建依赖对象；而IoC是有专门一个容器来创建这些对象，即由Ioc容器来控制对 象的创建；谁控制谁？当然是IoC 容器控制了对象；控制什么？那就是主要控制了外部资源获取（不只是对象包括比如文件等）。 ●为何是反转，哪些方面反转了：有反转就有正转，传统应用程序是由我们自己在对象中主动控制去直接获取依赖对象，也就是正转；而反转则是由容器来帮忙创建及注入依赖对象；为何是反转？因为由容器帮我们查找及注入依赖对象，对象只是被动的接受依赖对象，所以是反转；哪些方面反转了？依赖对象的获取被反转了。 用图例说明一下，传统程序设计如图2-1，都是主动去创建相关对象然后再组合起来： 图1-1 传统应用程序示意图 当有了IoC/DI的容器后，在客户端类中不再主动去创建这些对象了，如图2-2所示: 图1-2有IoC/DI容器后程序结构示意图 IoC能做什么 IoC 不是一种技术，只是一种思想，一个重要的面向对象编程的法则，它能指导我们如何设计出松耦合、更优良的程序。传统应用程序都是由我们在类内部主动创建依赖对象，从而导致类与类之间高耦合，难于测试；有了IoC容器后，把创建和查找依赖对象的控制权交给了容器，由容器进行注入组合对象，所以对象与对象之间是 松散耦合，这样也方便测试，利于功能复用，更重要的是使得程序的整个体系结构变得非常灵活。 其实IoC对编程带来的最大改变不是从代码上，而是从思想上，发生了“主从换位”的变化。应用程序原本是老大，要获取什么资源都是主动出击，但是在IoC/DI思想中，应用程序就变成被动的了，被动的等待IoC容器来创建并注入它所需要的资源了。 IoC很好的体现了面向对象设计法则之一—— 好莱坞法则：“别找我们，我们找你”；即由IoC容器帮对象找相应的依赖对象并注入，而不是由对象主动去找。 IoC和DI DI—Dependency Injection，即“依赖注入”：组件之间依赖关系由容器在运行期决定，形象的说，即由容器动态的将某个依赖关系注入到组件之中。依赖注入的目的并非为软件系统带来更多功能，而是为了提升组件重用的频率，并为系统搭建一个灵活、可扩展的平台。通过依赖注入机制，我们只需要通过简单的配置，而无需任何代码就可指定目标需要的资源，完成自身的业务逻辑，而不需要关心具体的资源来自何处，由谁实现。 理解DI的关键是：“谁依赖谁，为什么需要依赖，谁注入谁，注入了什么”，那我们来深入分析一下： ●谁依赖于谁：当然是应用程序依赖于IoC容器； ●为什么需要依赖：**应用程序需要IoC容器来提供对象需要的外部资源**； ●谁注入谁：很明显是IoC容器注入应用程序某个对象，应用程序依赖的对象； ●注入了什么：就是注入某个对象所需要的外部资源（包括对象、资源、常量数据）。 IoC和DI由什么关系呢？其实它们是同一个概念的不同角度描述，由于控制反转概念比较含糊（可能只是理解为容器控制对象这一个层面，很难让人想到谁来维护对象关系），所以2004年大师级人物Martin Fowler又给出了一个新的名字：“依赖注入”，相对IoC 而言，“**依赖注入”明确描述了“被注入对象依赖IoC容器配置依赖对象”。**]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>IOC</tag>
        <tag>DI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AOP]]></title>
    <url>%2F2019%2F05%2F20%2FAOP%2F</url>
    <content type="text"><![CDATA[AOP其实并不难，但是作为初学者，就不那么容易理解了。这里自己遇到了一点困惑，就记录一下吧。 什么是AOP参考《Spring实战》 了解之前，先说说什么是横切关注点，什么是核心关注点。 在软件开发中，散落于应用中多处的功能被称为横切关注点。横切关注点可以被模块化为特殊的类（将那些多个类的公共部分，与业务无关，却为业务模块所共同调用的东西封装到一个可重用模块），即切面（Aspect）。 然后核心关注点，就是业务主要的功能。 Aop 的作用在于分离系统中的各种关注点，将核心关注点和横切关注点分离开来。 为什么要这样做呢？ 这样做有两个好处：首先，现在每个关注点都集中于一个地方，而不是分散到多处代码中；其次，服务模块更简洁，因为它们只包含主要关注点（或核心功能）的代码，而次要关注点的代码被转移到切面中了。 AOP相关概念传送门https://blog.csdn.net/q982151756/article/details/80513340 Aspect（切面）： Aspect 声明类似于 Java 中的类声明，在 Aspect 中会包含着一些 Pointcut 以及相应的 Advice。 Joint point（连接点）：表示在程序中明确定义的点，典型的包括方法调用，对类成员的访问以及异常处理程序块的执行等等。 Pointcut（切点）：表示一组 joint point，这些 joint point 或是通过逻辑关系组合起来，或是通过通配、正则表达式等方式集中起来，它定义了相应的 Advice 将要发生的地方。 Advice（增强）：Advice 定义了在 Pointcut 里面定义的程序点具体要做的操作，它通过 before、after 和 around 来区别是在每个 joint point 之前、之后还是代替执行的代码。 Target（目标对象）：织入 Advice 的目标对象.。 Weaving（织入）：将 Aspect 和其他对象连接起来, 并创建 Adviced object 的过程。]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>AOP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[彻底解决gite clone 时 The remote end hung up unexpectedly错误]]></title>
    <url>%2F2019%2F05%2F20%2Fgit3%2F</url>
    <content type="text"><![CDATA[网上搜了很多 什么增大一下缓存，还看一下生效了没 git config http.postBuffer 524288000 git config –list 什么增加lowSpeedTime git config –global http.lowSpeedLimit 0 git config –global http.lowSpeedTime 999999 统统都没用 最后克隆的远程地址把http换做ssh就可以了 如果速度慢，可以git clone后加上–depth 1]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git克隆网速差，不反应的解决方案]]></title>
    <url>%2F2019%2F05%2F20%2Fgit2%2F</url>
    <content type="text"><![CDATA[git clone 克隆的是所有的历史版本 解决方案： 在git clone后面加上–depth 1 ，就可以大大减少要克隆的内容了 depth 1表示只克隆最近一次的commit. 例如： $ git clone –depth 1 git@github.com:litten/hexo-theme-yilia.git git clone 克隆的是所有的历史版本 解决方案： 在git clone后面加上–depth 1 ，就可以大大减少要克隆的内容了 depth 1表示只克隆最近一次的commit. 例如： $ git clone –depth 1 git@github.com:litten/hexo-theme-yilia.git]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git的使用]]></title>
    <url>%2F2019%2F05%2F20%2Fgit1%2F</url>
    <content type="text"><![CDATA[Git的结构 本地库和远程库1团队内部协作 2跨团队协作 Git命令行操作1本地库初始化git init git add 2设置签名项目级别/仓库级别：仅在当前本地库范围内有效 git config user.name tomgit config user.email goodMorning@aa.com 信息保存位置：./.git/config 文件 系统用户级别：登录当前操作系统的用户范围 git config –global user.name tomgit config –global user.email goodMorning@aa.com 3基本操作git status 查看工作区、暂存区状态 git add 将工作区的“新建/修改”添加到暂存区 git commit 将暂存区的内容提交到本地库 git reflog 查看历史记录 前进后退：基于索引值操作 git reset –hard[局部索引值] reset三个参数对比 –soft：仅仅在本地库移动HEAD 指针 –mixed：在本地库移动HEAD 指针，重置暂存区 –hard：在本地库移动HEAD 指针，重置暂存区和工作区 删除文件并找回 git add -&gt; git commit，将文件提交到本地库，使用git reset –hard[指针位置]，指针位置指向历史记录 git add只提交到暂存区，未提交到本地库，使用git reset –hard HEAD，指针位置使用HEAD，同时刷新工作区和暂存区。 4分支操作创建分支 git branch [分支名] 查看分支 git branch -v切换分支 git checkout [分支名]合并分支第一步：切换到接受修改的分支（被合并，增加新内容）上git checkout [被合并分支名] 第二步：执行merge 命令git merge [有新内容分支名] 5创建远程库查看当前所有远程地址别名 git remote -v 创建远程库地址别名 git remote add [别名] [远程地址] git remote add origin [远程地址] 推送 git push [别名] [分支名] git push origin [分支名] 克隆 git clone[远程地址] 克隆git仓库中的分支 git clone -b &lt;branch_name&gt; 如：git clone -b aa [远程地址] 拉取 pull = fetch + merge git fetch [远程库地址别名] [远程分支名]（fetch 抓取，fetch只是把远程库的内容下载到本地，并未改变本地工作区的文件。） git merge [远程库地址别名/远程分支名] git pull [远程库地址别名] [远程分支名] SSH登录 1.运行命令生成.ssh 密钥目录 $ ssh-keygen -t rsa -C atguigu2018ybuq@aliyun.com 2.进入.ssh 目录查看id_rsa.pub 文件内容 $ cat id_rsa.pub 3.复制id_rsa.pub 文件内容Setting -&gt; SSH keys 4.在Git bash 创建远程地址别名 git remote add origin_ssh git@github.com:atguigu2018ybuq/huashan.git]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[牛客网中级项目（一）]]></title>
    <url>%2F2019%2F05%2F14%2Fimages3%2F</url>
    <content type="text"><![CDATA[Controller控制器及常用注解SpringMVC中，控制器Controller负责处理由DispatcherServlet(前端控制器)分发的请求，它把用户请求的数据经过业务处理层处理之后封装成一个Model,然后再把该Model返回给对应的view进行展示。 控制器简而言之：就是接收和处理客户端的请求，spring通过注解控制器类，加载特定的控制器。 参数注解： @PathVariable：映射URL绑定的占位符 @RequestParam：注解获取GET和POST请求的参数，将指定的请求参数赋值给方法中的形参 @CookieValue 获取指定cookie的值 使用@RequestParam(value=”xxx”,required=false)时需要注意的问题 required=false：可以不传这个参数 required=true：必须传这个参数 required默认值是true 123456789@RequestMapping(value = "/profile/&#123;groupId&#125;/&#123;userId&#125;")@ResponseBodypublic String profile(@PathVariable("groupId") String groupId, @PathVariable("userId") int userId, @RequestParam(value = "type", defaultValue = "1") int type, @RequestParam(value = "key", defaultValue = "nowcoder") String key) &#123; //http://127.0.0.1:8080/profile/1/2?key=xx&amp;type=11 return String.format("GID&#123;%s&#125;, UID&#123;%d&#125;, TYPE&#123;%d&#125;, KEY&#123;%s&#125;", groupId, userId, type, key);&#125; 常用注解： @Configuration把一个类作为一个IoC容器，它的某个方法头上如果注册了 @Bean，就会作为这个Spring容器中的Bean。 @Scope注解 作用域 @Lazy(true) 表示延迟初始化 @Service用于标注业务层组件 @Controller用于标注控制层组件（如struts中的action） @Repository用于标注数据访问组件，即DAO组件。 @Component泛指组件，当组件不好归类的时候，我们可以使用这个注解进行标注。 @Scope用于指定scope作用域的（用在类上） @PostConstruct用于指定初始化方法（用在方法上） @PreDestory用于指定销毁方法（用在方法上） @DependsOn：定义Bean初始化及销毁时的顺序 @Primary：自动装配时当出现多个Bean候选者时，被注解为@Primary的Bean将作为首选者，否则将抛出异常 @Autowired 默认按类型装配，如果我们想使用按名称装配，可以结合@Qualifier注解一起使用。如下： @Autowired @Qualifier(“personDaoBean”) 存在多个实例配合使用 @Resource默认按名称装配，当找不到与名称匹配的bean才会按类型装配。 @PostConstruct 初始化注解 @PreDestroy 摧毁注解 默认 单例 启动就加载 @Async异步方法调用 Velocity模板语言为什么要使用模板语言？ 在服务器端可以使用Velocity处理模板和生成的动态内容（html，xml等）。和 JSP 技术的目标非常接近。但是，JSP 模型可以毫无阻碍地访问底层的 Servlet API 和 Java 编程语言。它基本上是一种在很大程度上开放的访问模型。 而作为一种完全自包含的模板引擎和脚本解释器，Velocity 拥有完全封闭的模型。任何针对系统和/或 Java 编程语言的访问都必须明确地启用。默认情况，Velocity 模板中不能访问 Java 编程语言的任何方面。这种封闭的模型使 Velocity 能够提供分离的模板表示层，与任何应用程序业务逻辑或者数据管理代码清晰地划分开。从而保证了网页的长期可维护性。 news.vm 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;html&gt;&lt;pre&gt; Hello VM.## 你看不到我#*这里都看不到我 *# value1: $!&#123;value1&#125;$!&#123;value2&#125;$&#123;value3&#125; #foreach($color in $!&#123;colors&#125;)Color $!&#123;foreach.index&#125;/$!&#123;foreach.count&#125;: $!&#123;color&#125;#end #foreach($key in $map.keySet())Number $!&#123;foreach.index&#125;/$!&#123;foreach.count&#125;: $!key $map.get($key)#end #foreach($kv in $map.entrySet())##kv.key,kv.value这是velocity的语法，不要和java混淆了Number1 $!&#123;foreach.index&#125;/$&#123;foreach.count&#125;: $!&#123;kv.key&#125; $!&#123;kv.value&#125;#end User: $!&#123;user.name&#125;User: $!&#123;user.getName()&#125; ##模板继承#set($title = "nowcoder")Include: #include("header.vm") &lt;br&gt;Parse: #parse("header.vm") ##自定义函数#macro(render_color $color, $index)Color By Macro $index, $color#end #foreach($color in $colors)#render_color($color, $index)#end ##定义变量#set($hello = "hello")#set($hword1 = "$!&#123;hello&#125;world")#set($hword2 = '$!&#123;hello&#125;world')hworld1: $hword1hworld2: $hword2 $!&#123;colors.size()&#125;&lt;/pre&gt;&lt;/html&gt; header.vm 1Title &lt;h&gt;$!title&lt;/h&gt; CookieCookie技术是将用户的数据存储到客户端的技术： 1.服务器端怎样将一个Cookie发送到客户端创建Cookie: Cookie cookie = new Cookie(key, value); 服务器端响应客户端，该cookie会以响应头的形式发送给客户端 向客户端发送cookie： response.addCookie(Cookie cookie); 12345678910@RequestMapping(value = "/response")@ResponseBodypublic String response(@CookieValue(value = "nowcoderid", defaultValue = "a") String nowcoderid, @RequestParam(value = "key", defaultValue = "key") String key, @RequestParam(value = "value", defaultValue = "value") String value, HttpServletResponse response) &#123; response.addCookie(new Cookie(key, value)); response.addHeader(key, value); return "NowCoderId From Cookie:" + nowcoderid;&#125; 2.服务器端怎样接收客户端携带的cookie客户端请求服务器，客户端存储的cookie信息是以请求头的方式发送到服务器端的 通过request获得所有的cookie： Cookie[] cookies = request.getCookies(); 遍历Cookie数组，通过cookie.getName();cookie.getValue();获得cookie的名称和值 1234567891011121314151617181920212223242526@RequestMapping(value = "/request")@ResponseBodypublic String request(HttpServletRequest request, HttpServletResponse response, HttpSession session) &#123; StringBuilder sb = new StringBuilder(); Enumeration&lt;String&gt; headerNames = request.getHeaderNames(); while(headerNames.hasMoreElements()) &#123; String name = headerNames.nextElement(); sb.append(name + ":" + request.getHeader(name) + "&lt;br&gt;"); &#125; for (Cookie cookie : request.getCookies()) &#123; sb.append("Cookie:"); sb.append(cookie.getName()); sb.append(":"); sb.append(cookie.getValue()); sb.append("&lt;br&gt;"); &#125; sb.append("getMethod:" + request.getMethod() + "&lt;br&gt;"); sb.append("getPathInfo:" + request.getPathInfo() + "&lt;br&gt;"); sb.append("getQueryString:" + request.getQueryString() + "&lt;br&gt;"); sb.append("getRequestURI:" + request.getRequestURI() + "&lt;br&gt;"); return sb.toString();&#125; 3.http实例服务器端发送cookie到客户端 new cookie(key, value);key=3,value=w。并addCookie()将cookie发送到客户端。（Set-Cookie:3=w） 默认cookie值为a,如果把请求的参数key改为nowcoderid,那么CookieValue的值就可以根据请求参数value来修改。 请求的地址（服务器地址） 请求头中的HOST是服务器域名和TCP端口号，如果使用的是服务请求标准端口号，端口号可以省略 不要被这里的127.0.01:8080所迷惑。 我们客户端是http://127.0.0.1:8080/，服务器端是http://127.0.0.1:8080/response?key=3&amp;value=w 这里的127.0.01:8080是从http://127.0.0.1:8080/response?key=3&amp;value=w中提取出来的域名 Host（发送请求时，该报头域是必需的）Host请求报头域主要用于指定被请求资源的Internet主机和端口号，它通常从HTTP URL中提取出来的， eg：我们在浏览器中输入：https://www.baidu.com/浏览器发送的请求消息中，就会包含Host请求报头域，如下：Host：www.baidu.com 客户端携带Cookie请求服务器不多说了 重定向301和302的区别 301代表永久性转移(Permanently Moved) 302代表暂时性转移(Temporarily Moved) 共同点：301和302状态码都表示重定向，就是说浏览器在拿到服务器返回的这个状态码后会自动跳转到一个新的URL地址，这个地址可以从响应的Location首部中获取（用户看到的效果就是他输入的地址A瞬间变成了另一个地址B） 不同点：301表示旧地址A的资源已经被永久地移除了（这个资源不可访问了）； 302表示旧地址A的资源还在（仍然可以访问），这个重定向只是临时地从旧地址A跳转到地址B； 12345678910111213141516/*@RequestMapping(value = "/redirect/&#123;coder&#125;")public RedirectView redirect(@PathVariable("coder") int coder) &#123; RedirectView red = new RedirectView("/", true); if (coder == 301) &#123; red.setStatusCode(HttpStatus.MOVED_PERMANENTLY); &#125; return red;&#125;*/ @RequestMapping(value = "/redirect/&#123;coder&#125;")public String redirect(@PathVariable("coder") int coder, HttpSession session) &#123; session.setAttribute("msg", "Jump For redirect."); //默认302跳转，永远不可能是301跳转 return "redirect:/";&#125; Session回顾Session技术是将数据存储在服务器端的技术，会为每个客户端都创建一块内存空间存储客户的数据，但客户端需要每次都携带一个标识ID去服务器中寻找属于自己的内存空间。所以说Session的实现是基于Cookie，Session需要借助于Cookie存储客户的唯一性标识JSESSIONID。 怎样获得客户端的session对象（内存区域）？ 客户端向服务器发出请求，调用getSession方法 HttpSession session = request.getSession(); 此方法会获得专属于当前会话的Session对象，如果服务器端没有该会话的Session 对象会创建一个新的Session返回，如果已经有了属于该会话的Session直接将已有的Session返回（实质就是根据JSESSIONID判断该客户端是否在服务器上已经存在session了） 怎样向session中存取数据（session也是一个域对象）？ session.setAttribute(String name,Object obj); session.getAttribute(String name); session.removeAttribute(String name); session对象的生命周期？ 创建：第一次执行request.getSession()时创建 销毁：服务器关闭、session过期/失效（默认30分钟） 手动销毁： session.invalidate(); session存取数据的简单使用1234567@RequestMapping(value = "/redirect/&#123;coder&#125;")public String redirect(@PathVariable("coder") int coder, HttpSession session) &#123; session.setAttribute("msg", "Jump For redirect."); //默认302跳转，永远不可能是301跳转 return "redirect:/";&#125; 12345@RequestMapping("/")@ResponseBodypublic String index(HttpSession session) &#123; return "Hello Nowcoder" + session.getAttribute("msg");&#125; 自定义error123456789101112131415@RequestMapping("/admin")@ResponseBodypublic String admin(@RequestParam(value = "key", required = false) String key) &#123; if("admin".equals(key)) &#123; return "hello admin"; &#125; throw new IllegalArgumentException("Key 错误");&#125; //自定义error,可以捕获Spring MVC外的或没有处理的Exception@ExceptionHandler()@ResponseBodypublic String error(Exception e) &#123; return "error:" + e.getMessage();&#125; IoC与DI详见：https://luchen0620.blog.csdn.net/article/details/89703174 1创建ToutiaoService类 12345678910package com.nowcoder.service; import org.springframework.stereotype.Service; @Servicepublic class ToutiaoService &#123; public String say() &#123; return "This is From ToutiaoService"; &#125;&#125; 1IndexController 1234567891011@Controllerpublic class IndexController &#123; @Autowired private ToutiaoService toutiaoService; @RequestMapping("/") @ResponseBody public String index(HttpSession session) &#123; return "Hello Nowcoder" + session.getAttribute("msg") + "&lt;br&gt;Say:" + toutiaoService.say(); &#125;&#125; AOP详见https://blog.csdn.net/qq_35396093/article/details/89712258 使用@Component注解，把切面类加入到IOC容器中 使用@Aspect注解，标记切面类 @Before 前置通知 @After 后置通知 LogAspect类 1234567891011121314151617181920212223242526272829package com.nowcoder.aspect; import org.aspectj.lang.JoinPoint;import org.aspectj.lang.annotation.After;import org.aspectj.lang.annotation.Aspect;import org.aspectj.lang.annotation.Before;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.stereotype.Component; @Aspect@Componentpublic class LogAspect &#123; private static final Logger logger = LoggerFactory.getLogger(LogAspect.class); @Before("execution(* com.nowcoder.controller.IndexController.*(..))") public void beforeMethod(JoinPoint joinPoint) &#123; StringBuilder sb = new StringBuilder(); for (Object args : joinPoint.getArgs()) &#123; sb.append("args:" + args.toString() + "|"); &#125; logger.info("before method：" + sb.toString()); &#125; @After("execution(* com.nowcoder.controller.IndexController.*(..))") public void afterMethod(JoinPoint joinPoint) &#123; logger.info("after method："); &#125;&#125;]]></content>
      <categories>
        <category>项目</category>
      </categories>
      <tags>
        <tag>AOP</tag>
        <tag>IOC</tag>
        <tag>DI</tag>
        <tag>Controller</tag>
        <tag>Velocity</tag>
        <tag>Cookie</tag>
        <tag>Session</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用Typora插入图片CSDN同步hexo]]></title>
    <url>%2F2019%2F05%2F14%2Fusetupian%2F</url>
    <content type="text"><![CDATA[1.根目录下面的_config.yml叫做站点配置文件，把_config.yml中的post_asset_folder设置为true。 2.安装图片插件，npm install hexo-asset-image –save。 3.运行hexo n “images3”在/source/_posts下生成images3.md，同时生成images3文件夹。4.用火狐抓取要同步的CSDN博客5.用Typora打开images3，编辑–&gt;图片工具–&gt;全局图像设置，图片插入按下图设置。 /images3表示在source目录下，./images3表示在/source/_posts目录下。6.复制抓取到的html到Typora，会自动保存图片到/source/_posts/images3目录下 图片格式为:! [img] (images3/图片名.png)保存后如果页面的html语句是&lt;img src=”2019/05/14/images3/图片名.png”就ok了]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>Typora</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GitHub Pages+Coding Pages+域名绑定]]></title>
    <url>%2F2019%2F05%2F14%2Fimages2%2F</url>
    <content type="text"><![CDATA[通过xxxxxx.github.io来访问不怎么cool，那就绑定属于自己的域名吧。 首先去阿里云购买域名并实名认证，这个就不细说了 设置域名解析点击解析设置 添加记录 记录类型选A 记录值就是ip地址，github提供了两个IP地址，192.30.252.153和192.30.252.154，这两个IP地址为github的服务器地址，两个都要填上，你还可以ping 部署在github上的地址。主机记录设置为@，线路就默认就行了。 记录类型选CNAME 记录值就是你的github博客地址。主机记录设置为www，线路就默认就行了。 在你的项目文件根目录的source文件下创建CNAME文件，不带任何后缀，里面添加你的域名信息，比如www.freeneasy.top Github Pages绑定域名在你的项目里点击Setting 往下拖，找到GitHub Pages，在Custom domain输入你要绑定的域名，并save 就OK了 Coding Pages绑定域名在代码的Pages服务中一键开启Coding Pages 然后绑定新域名www.freeneasy.top 就ok了]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo+github/Coding个人博客搭建]]></title>
    <url>%2F2019%2F05%2F14%2Fimages1%2F</url>
    <content type="text"><![CDATA[前期准备申请个github账号，腾讯云开发者账号https://dev.tencent.com/，安装git，安装Node.js，这个百度傻瓜式安装即可 安装hexo新建一个文件夹例如hexo，鼠标右键Git Bash Here 安装cnpm提升一下速度，感觉用处不大 npm install -g cnpm –registry=https://registry.npm.taobao.org 安装hexo cnpm install -g hexo-cli验证一下安装成功了没 hexo -v 新建一个文件夹比如MyBlog，搭建你的项目，鼠标右键Git Bash Here，在git中操作 hexo init hexo常用命令123456789hexo clean #用来清理缓存文件&lt;div class="hljs-ln-line hljs-ln-n" data-line-number="2"&gt;hexo g #生成文件&lt;div class="hljs-ln-line hljs-ln-n" data-line-number="3"&gt;hexo s #运行本地服务器&lt;div class="hljs-ln-line hljs-ln-n" data-line-number="4"&gt;hexo d #上传到服务器 hexo s 在浏览器中localhost:4000，本地搭建成功 部署到github配置github，New repository，注意名字必须这么写 配置SSH 1）先设置签名 git config –global user.name xxxgit config –global user.email xxxx@qq.com 2）运行生成一下.ssh $ ssh-keygen -t rsa -C xxxx@qq.com 3）进入.ssh 目录（例如C:\Users\luche.ssh）打开id_rsa.pub 4）复制id_rsa.pub 文件内容在github上Setting -&gt; SSH keys（很简单不详写了） 修改站点配置文件 根目录下面的_config.yml叫做站点配置文件而进入themes–&gt;主题–&gt;_config.yml的文件叫做主题配置文件 打开站点配置文件修改 安装deploy-git ，也就是部署的命令。 cnpm install –save hexo-deployer-git 先本地试试 hexo clean hexo g hexo s 把文件传送到github上 hexo d 然后就可以通过freeNeasy-lc.github.io来访问了 部署到Coding进入开发者平台新建项目 配置SSH 进入.ssh 打开id_rsa.pub 复制内容 打开项目，在设置里面部署公钥即可 修改站点配置文件 把文件部署到腾讯开发者平台 hexo d 就ok了]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>
